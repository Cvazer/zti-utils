# zti-utils
Библиотека java, содержащая несколько полезных классов, которые упрощают разработку и помагают мне в моих видео уроках.

### ConsoleScanner ###
Полезный класс, который позволяет быстро и легко создавать консольные приложения в Java.

Для того, чтобы начать использовать **ConsoleScanner** достаточно просто создать объект, и передать ему в качестве параметров _префикс комманды_ и _префикс параметра_ 
```java
ConsoleScanner scanner = new ConsoleScanner("/", "-");
```
В таком виде сканнер будет работать _синхронно_ с приложением, и считать ввод вы сможете с помощью вызова метода ```scanner.scan()```. Если же вызвать конструктор с boolean параметром  ```false```, то сканнер будет работать в асинхронном режиме, и все комманды, которые в него добавлены, будут выполняться в отдельном потоке:
```java
ConsoleScanner scanner = new ConsoleScanner("/", "-", false);
```
В случае использования асинхронного метода для начала сканнирования вызовите на объектре сканнера метод ```scanner.start()```, а для остановки ```scanner.stop()```.
###### Добавление команды в сканнер ######
Внутри класса ConsoleScanner имеется список добавленных в него команд, которые представлены классом ```Command.java```. Для добавление новой комманды в сканнер создайте экземпляр класса **Command**, и в качестве параметров передайте ему имя комманды и краткое описание.
```java
Command command = new Command("test", "This is a test command");
```
Затем добавьте комманду в сканнер вызвав на последнем метод ```scanner.addCommand(command)```. Сканнер сам подхватит ее во время работы (синхронной или нет).

###### Создание логики для комманды ######
После того, как вы создали и добавили в сканнер комманду стоит задать для нее логику выполнения. В ходе своей работы сканнер читает входящий поток, и, при совпадении с коммандой на входе, он разбирает входящую строку на параметры исподьзуя данные о префиксе параметров, переданные ему через конструктор. Пример для комманды test: ```/test -n Name -s Surname```, где _-n_ и _-s_ параметры комманды, а _Name_ и _Surname_ значения этих параметров.
Так как одному параметру может соответствовать несколько значений сканнер складывает каждое значение для параметра во внутренний список ```List<String> values;```, затем создает карту ```Map<String, List<String>> params;``` и используя имя параметра как ключь заносит все списки в соответствующие места в карте. После чего передает управление внутреннему методу, который передает текущую карту параметров на выполнение объекту, который расширяет интерфейс ```Consumable``` и находится внутри объекта соответствующей комманды. Все, что остается программисту - это определить поведение этого самого объекта _Consumable_

Для того, чтобы определить объект расширяющий интерфейс _Consumable_ нужно вызвать на комманде метод ```setConsumer(Consumable consumable)```. Пример кода:
```java
command.setConsumer(new Consumable() {
    @Override
    public void consume(Map<String, List<String>> map) {
      //Логика комманды
    }
});
```
Естественно, вместо анонимного класса можно использовать внутренний, или использовать лямбду:
```java 
command.setConsumer(map -> {
    //Логика комманды
});
```
При этом передоваемая методу _consume_ карта - это набор параметров и их значений в соответствии со спецификациями карты. Иногда возникает необходимость при вызове комманды передовать ей значения без параметров ```/test something```. В таком случает в сканнере предусмотрен ключь по умолчанию, который будет использоват для помещения значений в карту параметров. Значение этого ключа можно получить и задать программно.

Стоит отметить, что метод ```setConsumer(Consmable consumable);``` возвращает сам себя (объект типа _Command_), и его можно вызывать в ходе инициализации экземпляра класса _Command_ ```scanner.addCommand(new Command("test, "").setConsumer(new Consumable()...));```

###### Дополнительные сведения ######

Метод ```scanner.setWelcome(String s)``` позволяет задать сообщение приветствия, которое появляется автоматически при асинхронной работе сканера. Если вы не хотите, чтобы оно отображалось - просто передайте в качетве параметра пустые скобки строки "".

Методы ```scanner.getCommandPrefix()``` и ```scanner.setCommandPrefix(String prefix)``` можно использовать для получения строки префикса комманды, и для ее установки вне конструктора соответственно.

Методы ```scanner.getParamPrefix()``` и ```scanner.setParamPrefix(String prefix)``` можно использовать для получения строки префикса параметра, и для ее установки вне конструктора соответственно.

Методы ```scanner.getDefaultKey()``` и ```scanner.setDefaultKey(String key)``` можно использовать для получения строки ключа по умолчанию, и для ее установки соответственно.

###### Пример использования ######
Синхронная программа пересмешник:
```java
import by.zti.main.scanner.Command;
import by.zti.main.scanner.ConsoleScanner;

public class Main {

    public static void main(String[] args) {
        ConsoleScanner scanner = new ConsoleScanner("/", "-");
        scanner.addCommand(new Command("say", "").setConsumer(map -> map.get(scanner.getDefaultKey()).forEach(System.out::println)));
        scanner.start();
    }
}
```
Вывод:
```java
/say Hello
Hello

Process finished with exit code 0
```

Асинхронная программа пересмешник с коммандой для выхода:
```java
import by.zti.main.scanner.Command;
import by.zti.main.scanner.ConsoleScanner;

public class Main {

    public static void main(String[] args) {
        ConsoleScanner scanner = new ConsoleScanner("/", "-", false);
        scanner.setWelcome("");
        scanner.addCommand(new Command("say", "").setConsumer(map -> map.get(scanner.getDefaultKey()).forEach(System.out::println)));
        scanner.addCommand(new Command("exit", "").setConsumer(map -> scanner.stop()));
        scanner.start();
    }
}
```
Вывод: 
```java 
/say Hello
Hello
/exit

Process finished with exit code 0
```
